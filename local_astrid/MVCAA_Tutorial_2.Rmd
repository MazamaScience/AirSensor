---
title: "MVCAA Tutorial 2: Exploring PAT Data"
author: "Mazama Science"
date: "2021-03-12"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MVCAA Tutorial 2: Exploring PAT Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height = 5)
```

## Introduction

This tutorial demonstrates basic exploration of previously created 'pat' 
timeseries data. In order to run the code in this tutoral you must have 
followed the instructions in Tutorial 1 and created a directory with 'pas' 
and 'pat' data files for the Methow Valley. Target
audiences include grad students, researchers and any member of the public
concerned about air quality and comfortable working with R and RStudio.

Tutorials in this series include:

* [MVCAA Tutorial 1: Creating PAT Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_1.html)
* [MVCAA Tutorial 2: Examining PAT Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_2.html)
* [MVCAA Tutorial 3: Creating Airsensor Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_3.html)
* [MVCAA Tutorial 4: Exploring Airsensor Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_4.html)
* [MVCAA Tutorial 5: Building a Local Archive](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_5.html)
* [MVCAA Tutorial 6: Using a Local Archive](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_6.html)
* [MVCAA Tutorial 7: Methow Vallely Smoke](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_7.html)

## Goal

Our goal in this tutorial is to explore a variety of `pat_~()` functions available
in the **AirSensor** package and to explain their most important arguments and 
the interpretation of output graphics.

## How to interpret the graphics
PurpleAir (PA) sensors are unique in that they have two separate optical particle 
detectors — one labeled A and one labeled B.
All of the plotting functions, except `pat_monitorComparison()` and 
`pat_externalFit()`, only use data from a *single* PA sensor — with A and B data channels. When measurements from the A and B channels are largely in agreement 
then the sensor is working properly. When they substantially differ, there is 
a problem. Moreover, when a sensor is properly functioning, correlation between 
the A and B channel (pm25_A:pm25_B) will be strongly positive, while correlation
between temperature and humidity will be strongly negative.

## Refresh from MVCAA Tutorial 1: Creating `pat` objects
```{r, eval=FALSE}
# Load files (your archiveDir was defined in Tutorial 1 and should be in your R 
# environment)
patList <- get(load(file.path(archiveDir,"/patList.rda")))

# Print site names and associated ids
sapply(patList, function(x) { return(x$meta$label) }) 

# Pull out each sensor as a separate 'pat' object
Balky_Hill <- patList[["ab5dca99422f2c0d_13669"]]
Bush_School <- patList[["49215ad49d1a87e3_10188"]]
Liberty_School <- patList[["db5d6b3b79f5830e_39237"]] # good
McFarland_Creek <- patList[["f592adb5067ad9d3_13675"]]
Pine_Forest <- patList[["0cbfeb2ce4c1553c_13661"]]
Willowbrook_Farm <- patList[["f96deab8c29aa42b_10134"]]
Benson_Creek <- patList[["f6c44edd41c941c7_10182"]]
Gunn_Ranch <- patList[["f736fd3fb21fc4da_13667"]]
Lower_Studhorse <- patList[["4f19d256e1787973_10166"]]
Methow_Estates <- patList[["4a47b9252e16e558_15077"]] 
Beaver_Creek <- patList[["2e3b5ceea86a885b_10168"]]
Little_Cougar <- patList[["96b108298883ca47_64441"]]
```

## [pat_dygraph](https://mazamascience.github.io/AirSensor/reference/pat_dygraph.html)
This function creates interactive graphs that will be displayed in RStudio's 'Viewer' tab.

Lets explore a couple of sensors. 

### Liberty School
```{r Liberty-School, eval=FALSE}
pat_dygraph(
  pat = Liberty_School, 
  parameter = "pm25",
  sampleSize = 1000,
  title = NULL,
  xlab = "September 2020",
  ylab = NULL,
  tlim = NULL,
  rollPeriod = 6,
  showLegend = TRUE,
  colors = NULL,
  timezone = NULL
)

```


### Willowbrook Farm
```{r, Willowbrook_Farm, eval=FALSE }
pat_dygraph(
  pat = Willowbrook_Farm,       
  parameter = "pm25",
  sampleSize = 1000,
  title = NULL,
  xlab = "September 2020",
  ylab = NULL,
  tlim = NULL,
  rollPeriod = 6,
  showLegend = TRUE,
  colors = NULL,
  timezone = NULL)
```

Both graphs show missing data for one of the two channels on certain days, 
and the episodes are isolated. Days with missing data 
are not unusual events. However, this can be considered more or less relavant 
depending on the importance that the missing data could have in your study. 

For Liberty School, the A and B channel measurements are largely in agreement 
while for Willowbrook Farm, the channels are largely in disagreement. This could 
indicate a malfunctioning of the sensor, and it could be interesting to investigate
if this is an isolated event by exploring a larger time range. 


## pat_multiPlot() 
This function allow us to quickly display our raw `pat` data using the desired 
plottype. Available `plottype` options include:

* "all" – pm25_A, pm25_B, temperature, humidity

* "pm25_a" – PM2.5 from channel A only

* "pm25_b" – PM2.5 from channel B only

* "pm25" – PM2.5 from channels A and B in separate plots

* "pm25_over" – PM2.5 from channels A and B in the same plot

* "aux" – auxiliary data (temperature, humidity)

For the purpuse of this turorial we'll use "all", "pm25_over", and "aux".

```{r Liberty-School-all, eval=FALSE}
# Liberty School multiplot - plottype = "all"
  pat_multiPlot(
    pat = Liberty_School,
    plottype = "all",
    sampleSize = 1000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
The "all" plot type offers a nice overview of all four variables. We can 
already start seeing an agreement between channel A and B data and an inverse relationship between humidity and temperature measurments. 

Let's give a closer look at the channels using the "pm25_over" plot type. 
```{r, Liberty-School-pm25over, eval=FALSE}
# Liberty School multiplot - plottype = "pm25_over"
  pat_multiPlot(
    pat = Liberty_School,
    plottype = "pm25_over",
    sampleSize = 1000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
Channels A and B show strong agreement, and we can strengthen our assumption by 
increasing the sample size. 

Let's try `sampleSize = 5000`. 
```{r, Liberty-School-pm25over-n5000, eval=FALSE}
# Balky Hill multiplot - plottype = "pm25_over", sampleSize = 5000
  pat_multiPlot(
    pat = Liberty_School,
    plottype = "pm25_over",
    sampleSize = 5000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
The trend looks consistent, channels A and B are largely in agreement. Purely 
based on visual interpreation, we could assume that the Liberty School sensor is 
working correctly. However, more in-depth statistical analysis is discussed later 
in this tutorial. 

Let's give a closer look at the relationship between temperature and humidity 
by using the "aux" plot type.
```{r, Liberty-School-aux, eval=FALSE}
# Liberty School multiplot - plottype = "aux"
  pat_multiPlot(
    pat = Balky_Hill,
    plottype = "aux",
    sampleSize = 5000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
From the graph, we can start inferring a negative correlation between the two 
variables, which supports the assumption that the sensor is functioning correctly. 

## [pat_scatterPlotMatrix()](https://mazamascience.github.io/AirSensor/reference/pat_scatterPlotMatrix.html)

This function returns a matrix of scatterplots and correlation values for the 
"pm25_A", "pm25_B", "temperature", and "humidity" variable in the `pat` object. 

The list of available parameters include:

* datetime -- measurement time

* pm25_A -- A channel PM2.5 (ug/m3)

* pm25_B -- B channel PM2.5 (ug/m3)

* temperature -- temperature (F)

* humidity -- humidity (%)

Let's compare all of them for the Liberty School sensor.  

```{r, pat-scatterPlotMatrix-Liberty-School, eval=FALSE}
# Liberty School scatterPlotMatrix
pat_scatterPlotMatrix(
  pat = Liberty_School,
  parameters = c("datetime", "pm25_A", "pm25_B", "temperature", "humidity"),
  sampleSize = 5000,
  sampleFraction = NULL,
  size = 0.5,
  shape = 15,
  color = "black",
  alpha = 0.25
)
```

As we can see from the matrix, using a sample size of 5000 observations 
for each variable, there is a perfect positive correlation of 1 between 
channels A and B (pm25_A:pm25_B) and a strong negative correlation of -0.839 
between temperature and humidity. These results support the assumption that the 
sensor worked well throughout September 2020. 

## [pat_outliers()](https://mazamascience.github.io/AirSensor/reference/pat_outliers.html)

This function detects outliers using a Median Average Deviation "Hampel" filter, 
appling a rolling Hampel filter to find those points that are very far out in 
the tails of the distribution of values within the window. 

`windowSize = 15` corresponds to a temporal window of approximately 30 minutes.

The default threshold setting `thresholdMin = 8` identifies points that are
extremely unlikely to be part of a normal distribution and therefore very likely
to be an outlier.

Specifying `replace = TRUE` allows you to perform smoothing by replacing outliers
with the window median value. Using this technique, you can create an highly 
smoothed, artificial dataset by setting thresholdMin = 1 or lower (but always 
above zero).

In order to store the new dataset including the replaced values, you can create 
a new pat object and save it in your archive directory (already defined in 
Tutorial 1) as in the example below. 


```{r, pat-outliers-Liberty-School, replace true, eval=FALSE}
# create an outliers plot for Liberty School 
Liberty_School_new <- pat_outliers(
  pat = Liberty_School,
  windowSize = 15,
  thresholdMin = 8,
  replace = TRUE,
  showPlot = TRUE,
  data_shape = 18,
  data_size = 1,
  data_color = "black",
  data_alpha = 0.5,
  outlier_shape = 8,
  outlier_size = 1,
  outlier_color = "red",
  outlier_alpha = 1
)

# Liberty_School_new contains the replaced values and can be saved in your archive 
# directory.
save(Liberty_School_new, file = file.path(archiveDir, "Liberty_School_new.rda"))
```

The plot shows a few non-concerning outliers. This function will always capture 
some outliers, and those that we may want to replace with the window median 
value would occur further away from the main distribution as depicted in the example 
below (notice data around August 3, 2018). 

```{r AirSensor-example-patoutliers(), eval=FALSE }
example_pat %>%
  pat_filterDate(20180801, 20180815) %>%
  pat_outliers(replace = TRUE, showPlot = TRUE)
```

## [pat_internalFit()](https://mazamascience.github.io/AirSensor/reference/pat_internalFit.html)
This function uses a linear model to fit data from channel B to data from 
channel A. If you save the model into an object, you can then interrogate the 
linear model using the `base` function `summary()`. 

Set `showPlot = TRUE` if you
want to generate an utterly beautiful model fit plot.  

Let's have a look at a well fucntioning sensor and to a not-so-well functioning
one. 

```{r, lm-Liberty-School, eval=FALSE}
# Liberty School linear model 
library(AirSensor)
lm_Liberty <- pat_internalFit(
  pat = Liberty_School,
  showPlot = TRUE,
  size = 1,
  a_color = "red",
  b_color = "blue",
  alpha = 0.25,
  lr_shape = 15,
  lr_color = "black",
  lr_lwd = 1.5,
  lr_lcolor = "tomato",
  lr_lalpha = 0.45,
  ts_shape = 1,
  xylim = NULL
)

summary(lm_Liberty)
```
The model fit plot shows that the model is slightly biased towards channel B 
(slope = 0.95) and that the linear model explains 99.9% of the data variability.
This supports the assumption that the Liberty School sensor functioned correctly
throughout most of September 2020.


```{r, lm-Willowbrook-Farm, eval=FALSE}
# Willowbrook Farm linear model
lm_Willowbrook <- pat_internalFit(
  pat = Willowbrook_Farm,
  showPlot = TRUE,
  size = 1,
  a_color = "red",
  b_color = "blue",
  alpha = 0.25,
  lr_shape = 15,
  lr_color = "black",
  lr_lwd = 1.5,
  lr_lcolor = "tomato",
  lr_lalpha = 0.45,
  ts_shape = 1,
  xylim = NULL
)

summary(lm_Willowbrook)
```
The model fit plot shows that the model is biased towards channel A 
(slope = 1.5), as aslo evident in the bottom graphic, indicating the 
malfunctioning of one or both Willowbrook Farm sensor's channels. 
The model explains only 92.2% of the data variability, reinforcing the assumption
that the sensor didn't function correctly throughout the entire month. 

## [pat_dailySoHPlot()](https://mazamascience.github.io/AirSensor/reference/pat_dailySoHIndexPlot.html)
This function plots a subset of the most useful State of Health metrics calculated 
by the [pat_dailySoH()](https://mazamascience.github.io/AirSensor/reference/pat_dailySoH.html) 
function. The function runs `pat_dailySoH()` internally and uses
the output to create the plot.
To better understand each plot, see also:

* [PurpleAirSoH_dailyPctReporting()](https://mazamascience.github.io/AirSensor/reference/PurpleAirSoH_dailyPctReporting.html), 
for `pm25_A_PctReporting` and `pm25_B_PctReporting`. Plots show the percentage of 
each day that the sensor is reporting data.

* [PurpleAirSoH_dailyPctValid()](https://mazamascience.github.io/AirSensor/reference/PurpleAirSoH_dailyPctValid.html), 
for `pm25_A_PctValid` and `pm25_B_PctValid`. Plots show percentage of the total 
recorded measurements that are considered plausible.

* [PurpleAirSoH_dailyPctDC()](https://mazamascience.github.io/AirSensor/reference/PurpleAirSoH_dailyPctDC.html), 
for `pm25_A_pctDC` and `pm25_B_pctDC`. A high percent DC (direct current) value 
indicates the likely occurrence of a “sticky value”, and a zero or low percent 
DC indicates that the sensor is recording dynamic data.

* [PurpleAirSoH_dailyMetFit()](https://mazamascience.github.io/AirSensor/reference/PurpleAirSoH_dailyMetFit.html), 
for `pm25_A_temperature_rsquared`. The plot show daily linear model values between 
the pm25_A and temperature channels. The daily r-squared value is returned and is
expected to hover near 0 for a properly functioning sensor, under normal 
environemntal conditions.

* [PurpleAirSoH_dailyABFit()](https://mazamascience.github.io/AirSensor/reference/PurpleAirSoH_dailyABFit.html), 
for `pm25_A_pm25_B_slope`, `pm25_A_pm25_B_intercept`, and `pm25_A_pm25_B_rsquared`.
Plots show daily linear model values between 
the pm25_A and pm25_B channels. The daily r-squared value is returned in addition to
the coefficients of the linear fit (slope and intercept).


```{r, pat_dailySoHPlot-Liberty-School, eval= FALSE}
# create plots for Liberty School
pat_dailySoHPlot(Liberty_School, ncol = 2)
```
The plot that grabs our attention the most is `pm25_A_temperature_rsquared` given 
the persistent spikes occurring throughout the month. Values are expected to hover near 0 for 
a properly functioning sensor under normal environemntal conditions. 
Wildfire events during summer and the heavy use of heating systems during winter
could explain fluctuating R squared values.
In this case, it's possible that the spikes recorded in this plot are due to 
wildfire events around that period.

The `pm25_A_pctDC` plot shows that channel A
recorded dynamic data (value > 0) towards the beginning and the end of the month
in contrast to channel B (`pm25_B_pctDC`), which collected sticky values throughout 
the entire month. 
We notice that this overlaps with periods when the R squared values were lower 
as shown in the `pm25_A_pm25_B_rsquared` plot. Especially at the beginning of the 
month, the plot shows R squared values hovering around zero, 
indicating the poor functioning of the sensor.


## [pat_monitorComparison()](https://mazamascience.github.io/AirSensor/reference/pat_monitorComparison.html)
This function creates and returns a ggplot object that plots raw pat data, 
hourly aggregated pat data and hourly data from the nearest federal monitor 
from the [PWFSL database](https://haze.airfire.org/monitoring/).

If the nearest federal monitor didn't collect data during the period of time investigated
or is not within the distance specified, it is possible that you'll ecounter the following error: 
` Error in monitor_subset(ws_monitor, tlim = c(starttime, endtime)) : ws_monitor object contains zero monitors`.
You can try to change the `distanceCutoff = 20` to 50 (km). However, 20 km is the 
reccomended distance for the best analysis. Additionally you could use the AirFire 
tool [Monitoring v4.1](https://tools.airfire.org/monitoring/v4/#!/?monitors=530470010_01&monitors=840530470016_01&monitors=530070007_01&category=PM2.5_nowcast&centerlat=48.21&centerlon=-120.1498&zoom=8) to gather more info about the 
federal monitors in your area of interest and discover their exact location. 

The `FUN` argument lets you specify which algorithm to use in order to apply 
hourly aggregation QC. 
For specific details on the QC logic, have look at the online documentation avialable 
for each of the four algorithms: [PurpleAirQC_hourly_AB_00](https://mazamascience.github.io/AirSensor/reference/PurpleAirQC_hourly_AB_00.html), 
[PurpleAirQC_hourly_AB_01](https://mazamascience.github.io/AirSensor/reference/PurpleAirQC_hourly_AB_01.html), 
[PurpleAirQC_hourly_AB_02](https://mazamascience.github.io/AirSensor/reference/PurpleAirQC_hourly_AB_02.html), 
[PurpleAirQC_hourly_AB_03](https://mazamascience.github.io/AirSensor/reference/PurpleAirQC_hourly_AB_03.html).



```{r, patmonitorComparison() - Liberty_School, eval= FALSE}
# comparison plot for Liberty School sensor
pat_monitorComparison(
  pat = Liberty_School,
  FUN = AirSensor::PurpleAirQC_hourly_AB_01,
  distanceCutoff = 20,
  ylim = NULL,
  replaceOutliers = TRUE,
  timezone = NULL
)

# find out which is the nearest monitor
Liberty_School$meta$pwfsl_closestMonitorID # "530470010_01"
```

The graph shows in grey the sensor data before the QC treatment (PA raw), in purple 
the sensor data after the QC treatment (PA hourly), and in balck the data collected by 
the nearest federal monitor (Monitor). We observe some agreement between the PA 
hourly and the Monitor data. Their statistical relationship is discussed in the 
next section. 
 

## [pat_externalFit()](https://mazamascience.github.io/AirSensor/reference/pat_externalFit.html)
This function produces a linear model between data from PurpleAir and data from 
the closest PWFSL monitor (federal monitor). A diagnostic plot is produced if 
`showPlot = TRUE`.

# !

### Jon, since we are comparing PA sensor data to Monitor data, how tolerant can we be in assessing their relationship?

### Issue: I think the function uses the default qc_algorithm value despite I specify different ones. lm_01 and lm_00 look alike, which is not possible. 

```{r, patexternalFit-01 - Liberty_Schooll, eval= FALSE}
# create comparison plot for Liberty School sensor
lm_01 <- pat_externalFit(
  pat = Liberty_School,
  showPlot = TRUE,
  size = 1,
  pa_color = "purple",
  pwfsl_color = "black",
  alpha = 0.5,
  lr_shape = 15,
  lr_color = "black",
  lr_lwd = 1.5,
  lr_lcolor = "tomato",
  lr_lalpha = 0.45,
  ts_shape = 1,
  xylim = NULL,
  channel = "ab",
  replaceOutliers = TRUE,
  qc_algorithm = "hourly_AB_01",
  min_count = 20
)

summary(lm_01)

```

```{r, patexternalFit-00 - Liberty_Schooll, eval= FALSE}
# create comparison plot for Liberty School sensor
lm_00 <- pat_externalFit(
  pat = Liberty_School,
  showPlot = TRUE,
  size = 1,
  pa_color = "purple",
  pwfsl_color = "black",
  alpha = 0.5,
  lr_shape = 15,
  lr_color = "black",
  lr_lwd = 1.5,
  lr_lcolor = "tomato",
  lr_lalpha = 0.45,
  ts_shape = 1,
  xylim = NULL,
  channel = "ab",
  replaceOutliers = TRUE,
  qc_algorithm = "hourly_AB_00",
  min_count = 20
)

summary(lm_00)

```
----

_Best of luck assessing air quality in your community!_
