---
title: "MVCAA Tutorial 2: Exploring PAT Data"
author: "Mazama Science"
date: "2021-03-02"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MVCAA Tutorial 2: Exploring PAT Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height = 5)
```

## Introduction

This tutorial demonstrates basic exploration of previously created 'pat' 
timeseries data. In order to run the code in this tutoral you must have 
followed the instructions in Tutorial 1 and created a directory with 'pas' 
and 'pat' data files for the Methow Valley. Target
audiences include grad students, researchers and any member of the public
concerned about air quality and comfortable working with R and RStudio.

Tutorials in this series include:

* [MVCAA Tutorial 1: Creating PAT Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_1.html)
* [MVCAA Tutorial 2: Examining PAT Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_2.html)
* [MVCAA Tutorial 3: Creating Airsensor Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_3.html)
* [MVCAA Tutorial 4: Exploring Airsensor Data](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_4.html)
* [MVCAA Tutorial 5: Building a Local Archive](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_5.html)
* [MVCAA Tutorial 6: Using a Local Archive](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_6.html)
* [MVCAA Tutorial 7: Methow Vallely Smoke](https://mazamascience.github.io/AirSensor/articles/articles/MVCAA_Tutorial_7.html)

## Goal

Our goal in this tutorial is to explore a variety of `pat_~()` functions available
in the **AirSensor** package and to explain their most important arguments and 
the interpretation of output graphics.

## How to interpret the graphics
PurpleAir (PA) sensors are unique in that they have 2 separate optical particle 
detectors (hereafter "channels") — one labeled A and one labeled B.
All of the plotting functions, except `pat_monitorComparison()` and 
`pat_externalFit()`, only use data from a *single* PA sensor — with A and B data channels. When measurements from the A and B channels are largely in agreement 
then the sensor is working properly. When they substantially differ, there is 
a problem. Moreover, when a sensor is properly functioning, correlation between 
the A and B channel (pm25_A:pm25_B) will be strongly positive, while correlation
between temperature and humidity will be strongly negative.

## Refresh from MVCAA Tutorial 1: Creating PAT Data
```{r}
# Load files
patList <- get(load(paste0(archiveDir,"/patList.rda")))

# Print site names and associated ids
sapply(patList, function(x) { return(x$meta$label) }) 

# Pull out each sensor as a separate 'pat' object
# Jon, I'm pretty sure there is a nice loop to do this ... ****************************
# ... Didn't have time to explore how to do it 

Balky_Hill <- patList[["ab5dca99422f2c0d_13669"]]
Bush_School <- patList[["49215ad49d1a87e3_10188"]]
Liberty_School <- patList[["db5d6b3b79f5830e_39237"]]
McFarland_Creek <- patList[["f592adb5067ad9d3_13675"]]
Pine_Forest <- patList[["0cbfeb2ce4c1553c_13661"]]
Willowbrook_Farm <- patList[["f96deab8c29aa42b_10134"]]
Benson_Creek <- patList[["f6c44edd41c941c7_10182"]]
Gunn_Ranch <- patList[["f736fd3fb21fc4da_13667"]]
Lower_Studhorse <- patList[["f736fd3fb21fc4da_13667"]]
Methow_Estates <- patList[["4a47b9252e16e558_15077"]] 
Beaver_Creek <- patList[["2e3b5ceea86a885b_10168"]]
Little_Cougar <- patList[["96b108298883ca47_64441"]]
```


## [pat_dygraph](https://mazamascience.github.io/AirSensor/reference/pat_dygraph.html)
This function creates interactive graphs that will be displayed in RStudio's 'Viewer' tab.

Lets explore a couple of sensors. 

### Balky_Hill
```{r, Balky_Hill}
pat_dygraph(
  pat = Balky_Hill, 
  parameter = "pm25",
  sampleSize = 1000,
  title = NULL,
  xlab = "September 2020",
  ylab = NULL,
  tlim = NULL,
  rollPeriod = 6,
  showLegend = TRUE,
  colors = NULL,
  timezone = NULL
)

```


### Willowbrook_Farm
```{r, Willowbrook_Farm}
pat_dygraph(
  pat = Willowbrook_Farm,       
  parameter = "pm25",
  sampleSize = 1000,
  title = NULL,
  xlab = "September 2020",
  ylab = NULL,
  tlim = NULL,
  rollPeriod = 6,
  showLegend = TRUE,
  colors = NULL,
  timezone = NULL)
```

Both graphs show missing data for one of the two channels on certain days.
For Balky Hill, measurements from the A and B channels are largely in agreement 
while for Willowbrook Farm, the channels are largely in disagreement. This could 
indicate a malfunctioning of the sensor, and it would be interesting to investigate
if this is an isolated event by exploring a larger time range. 


WIP: left here
## pat_multiPlot() 
*****************Jon, I can't link the function because the doc online doesn't work (error 404)***************

This function allow us to quickly display our raw `pat` data and desired plot 
type. Available `plottype` options include:

* "all" – pm25_A, pm25_B, temperature, humidity

* "pm25_a" – PM2.5 from channel A only

* "pm25_b" – PM2.5 from channel B only

* "pm25" – PM2.5 from channels A and B in separate plots

* "pm25_over" – PM2.5 from channels A and B in the same plot

* "aux" – auxiliary data (temperature, humidity)

For the purpuse of this turorial we'll use "all", "pm25_over", and "aux".
```{r, pat_multiPlot - loop, eval=FALSE}
# create a test list of sensors to loop through 
test_list <- list(Balky_Hill, Bush_School, Liberty_School)

#tried loop but doesn't work
for (pat in test_list){
  pat_multiPlot(
    pat = pat,
    plottype = "all",
    sampleSize = 1000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )
}

```

```{r, Balky_Hill "all"}
  pat_multiPlot(
    pat = Balky_Hill,
    plottype = "all",
    sampleSize = 1000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
The "all" plot type offers a nice overview of all four variables. We can 
already start seeing an agreement between channel A and B data and an inverse relationship between humidity and temperature measurments. 

Let's give a closer look to the channels using the "pm25_over" plot type. 
```{r, Balky_Hill "pm25_over"}
  pat_multiPlot(
    pat = Balky_Hill,
    plottype = "pm25_over",
    sampleSize = 1000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
Channels A and B show strong agreement, and we can strengthen our assumption by 
increasing the sample size. Let's try `sampleSize = 5000`. 

```{r, Balky_Hill "pm25_over",  sampleSize = 5000}
  pat_multiPlot(
    pat = Balky_Hill,
    plottype = "pm25_over",
    sampleSize = 5000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
The trend looks consistent, channels A and B are largely in agreement, and we 
can assume that the Bulky Hill sensor is working correctly. 

Let's know more closely compare temperature and humidity by using the "aux" plot 
type.
```{r, Balky_Hill "aux"}
  pat_multiPlot(
    pat = Balky_Hill,
    plottype = "aux",
    sampleSize = 5000,
    columns = NULL,
    ylim = NULL,
    a_size = 1,
    a_shape = 15,
    a_color = rgb(0.9, 0.25, 0.2),
    b_size = 1,
    b_shape = 15,
    b_color = rgb(0.2, 0.25, 0.9),
    t_size = 1,
    t_shape = 15,
    t_color = "black",
    h_size = 1,
    h_shape = 15,
    h_color = "black",
    alpha = 0.5,
    timezone = NULL
  )

```
Fron the graph, we can start inferring a negative correlation between the two 
variables, which supports the assumption that the sensor is functioning correctly. 

## [pat_scatterPlotMatrix()](https://mazamascience.github.io/AirSensor/reference/pat_scatterPlotMatrix.html)

This function returns a matrix of scatterplots and correlation values for all  
variables in the `pat` object. A great way to validate or eject our previous 
assumptions. 

The list of available parameters include:

* datetime -- measurement time

* pm25_A -- A channel PM2.5 (ug/m3)

* pm25_B -- B channel PM2.5 (ug/m3)

* temperature -- temperature (F)

* humidity -- humidity (%)

Let's compare all of them for the Balky Hill sensor.  

```{r, pat_scatterPlotMatrix}
pat_scatterPlotMatrix(
  pat = Balky_Hill,
  parameters = c("datetime", "pm25_A", "pm25_B", "temperature", "humidity"),
  sampleSize = 5000,
  sampleFraction = NULL,
  size = 0.5,
  shape = 15,
  color = "black",
  alpha = 0.25
)
```

As we can see from the matrix, we have a perfect positive correlation of 1 between 
channels A and B (pm25_A:pm25_B) and a quite strong negative correlation of -0.862 
between temperature and humidity, using a sample size of 5000 measurments 
for each variable.  

## pat_outliers()

TODO

## pat_internalFit()

TODO

## pat_dailySoHPlot()

TODO

## pat_monitorComparison()

TODO

## pat_externalFit()

TODO



----

_Best of luck assessing air quality in your community!_
